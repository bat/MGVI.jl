var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Components-listing","page":"API","title":"Components listing","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:module]","category":"page"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/#MGVI.MGVI","page":"API","title":"MGVI.MGVI","text":"MGVI\n\nAn implementation of the Metric Gaussian Variational Inference algorithm.\n\n\n\n\n\n","category":"module"},{"location":"api/#MGVI.MGVIConfig","page":"API","title":"MGVI.MGVIConfig","text":"struct MVGIConfig\n\nMGVI clgorithm configuration.\n\nFields:\n\nlinar_solver: Linear solver to use, must be suitable for positive-definite operators\noptimizer: Optimization solver to use\noptimizer_opts: Optimization solver options\n\nlinsolver must be a solver supported by LinearSolve or MGVI.MatrixInversion. Use MatrixInversion only for low-dimensional problems.\n\noptimizer nay be MGVI.NewtonCG() or an optimization algorithm supported by Optimization or Optim. optimizer_opts is algorithm-specific.\n\n\n\n\n\n","category":"type"},{"location":"api/#MGVI.MGVIContext","page":"API","title":"MGVI.MGVIContext","text":"MGVIContext(rng::AbstractRNG, ad::AutoDiffOperators.ADSelector)\n\nSpecifies the linear operator type, RNG and automatic differentiation backend to be used by MGVI operations.\n\n\n\n\n\n","category":"type"},{"location":"api/#MGVI.MGVIResult","page":"API","title":"MGVI.MGVIResult","text":"struct MGVIResult\n\nState resulting from mgvi_step.\n\nFields:\n\nsmples: The samples drawn by MVGI\nmnlp: The mean of the negative non-normalized log-posterior over the samples\ninfo: Additional information given by the linear solver and optimization algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/#MGVI.MatrixInversion","page":"API","title":"MGVI.MatrixInversion","text":"struct MatrixInversion\n\nSolve linear systems by direct matrix inversion.\n\nNote: Will instantiate implicit matrices/operators in memory explicitly.\n\n\n\n\n\n","category":"type"},{"location":"api/#MGVI.NewtonCG","page":"API","title":"MGVI.NewtonCG","text":"struct NewtonCG\n\nConstructors:\n\n'''NewtonCG(; fields...)'''\n\nα::Float64: amount of previous NewtonCG improvement guarding the lower     bound to the improvement between consecutive cg iterations from     the second NewtonCG step on Default: 0.1\nsteps::Int64: Number of total NewtonCG steps Default: 4\ni₀::Int64: maximum number of cg iterations in the first NewtonCG step Default: 5\ni₁::Int64: maximum number of cg iterations from the second NewtonCG step on Default: 50\nlinesearcher::Any: LineSearcher that will be used after cg iterations are finished Default: StrongWolfe{Float64}()\n\n\n\n\n\n","category":"type"},{"location":"api/#MGVI.PDLinMapWithChol","page":"API","title":"MGVI.PDLinMapWithChol","text":"struct MGVI.PDLinMapWithChol{T} <: LinearMaps.LinearMap{T}\n\nA LinearMap that stores both a map and the lower-tringangular map of its Cholesky decomposition.\n\n\n\n\n\n","category":"type"},{"location":"api/#MGVI.ResidualSampler","page":"API","title":"MGVI.ResidualSampler","text":"struct ResidualSampler\n\nGenerates zero-centered samples from the posterior's covariance approximated by the Fisher information.\n\nThis sampler uses Conjugate Gradients to iteratively invert  the Fisher information, never instantiating the covariance in memory explicitly.\n\nThe Fisher information in canonical coordinates and Jacobian of the coordinate transformation are provided as arguments.\n\nConstructor:\n\nResidualSampler(f_model::Function, center_point::Vector{<:Real}, linear_solver, context::MGVIContext)\n\nlinear_solver must be a solver supported by LinearSolve or MGVI.MatrixInversion. Use MatrixInversion only for low-dimensional problems.\n\nCall MGVI.sample_residuals(s::ResidualSampler[, n::Integer]) to generate a single or n samples.\n\n\n\n\n\n","category":"type"},{"location":"api/#MGVI.fisher_information","page":"API","title":"MGVI.fisher_information","text":"MGVI.fisher_information(distribution::Distributions.Distribution)\n\nGet the fisher information matrix/operator (as a LinearMap) for the given distribution.\n\n\n\n\n\n","category":"function"},{"location":"api/#MGVI.mgvi_mvnormal_pushfwd_function-Tuple{Any, Any, MGVIConfig, AbstractVector{<:Real}, MGVIContext}","page":"API","title":"MGVI.mgvi_mvnormal_pushfwd_function","text":"mgvi_mvnormal_pushfwd_function(\n    forward_model, data, config::MGVIConfig,\n    center_point::AbstractVector{<:Real}, context::MGVIContext\n)\n\nReturns a function that pushes a multivariate normal distribution forward to the MGVI posterior approximation.\n\nThis currently instantiates the full Jabocian of the forward model as a matrix in memory, and so should not be used for very high-dimensional problems.\n\n\n\n\n\n","category":"method"},{"location":"api/#MGVI.mgvi_sample-Tuple{Any, Any, Integer, AbstractVector{<:Real}, MGVIConfig, MGVIContext}","page":"API","title":"MGVI.mgvi_sample","text":"mgvi_sample(\n    forward_model, data, n_residuals::Integer, center_init::AbstractVector{<:Real},\n    config::MGVIConfig, context::MGVIContext\n)\n\n\n\n\n\n","category":"method"},{"location":"api/#MGVI.mgvi_step-Tuple{Any, Any, Integer, AbstractVector{<:Real}, MGVIConfig, MGVIContext}","page":"API","title":"MGVI.mgvi_step","text":"mgvi_step(\n    forward_model, data, n_residuals::Integer, center_init::AbstractVector{<:Real},\n    config::MGVIConfig, context::MGVIContext\n)\n\nPerforms one MGVI step and returns a tuple (result::MGVIResult, updated_center::AbstractVector{<:Real}).\n\nReturns a tuple (result::MGVIResult, updated_center::AbstractVector{<:Real}).\n\nThe posterior distribution is approximated with a multivariate normal distribution. The covariance is approximated with the inverse Fisher information valuated at center_init. Samples are drawn according to this covariance, which are then used to estimate and minimize the KL divergence between the true posterior and the approximation.\n\nNote: The prior is implicit, it is a standard (uncorrelated) multivariate normal distribution of the same dimensionality as center_init.\n\nExample\n\nusing Random, Distributions, MGVI\nimport LinearSolve, Zygote\n\ncontext = MGVIContext(ADSelector(Zygote))\n\nmodel(x::AbstractVector) = Normal(x[1], 0.2)\ntrue_param = [2.0]\ndata = rand(model(true_param), 1)[1]\ncenter = [1.3]\n\nconfig = MGVIConfig(\n    linsolver = LinearSolve.KrylovJL_CG(),\n    optimizer = MGVI.NewtonCG()\n)\nn_residuals = 12\nn_steps = 5\n\nres, center = mgvi_step(model, data, n_residuals, center, config, context)\nfor i in 1:n_steps-1\n    res, center = mgvi_step(model, data, n_residuals, center, config, context)\nend\n\nsamples_from_est_covariance = res.samples\n\n\n\n\n\n","category":"method"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"advanced_tutorial/#Advanced-Tutorial","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"","category":"section"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"You can also download this tutorial as a Jupyter notebook and a plain Julia source file.","category":"page"},{"location":"advanced_tutorial/#Introduction","page":"Advanced Tutorial","title":"Introduction","text":"","category":"section"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"In this tutorial, we will fit the coal mining disaster dataset with a Gaussian process modulated Poisson process.","category":"page"},{"location":"advanced_tutorial/#Prepare-the-environment","page":"Advanced Tutorial","title":"Prepare the environment","text":"","category":"section"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"We start by importing:","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"MGVI for the posterior fit\nDistributions.jl and FFTW.jl to define the statistical model\nOptim.jl to pass Optim.Options to MGVI and to find Maximum a posteriori fit that we will use for comparison\nStatsBase.jl for histogram construction from the data and also for error bands visualization\nPlots.jl for visualization","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"using MGVI\n\nusing FillArrays\nusing DelimitedFiles\nusing LinearAlgebra\nusing Random\nusing StatsBase\nusing Distributions\nusing Optim\nusing ForwardDiffPullbacks\n\nusing Plots\nusing Plots.PlotMeasures\nPlots.default(legendfontsize=10, tickfontsize=10, grid=false, dpi=120, size=(500, 300))\n\nusing FFTW\n\nimport ForwardDiff, Zygote\nusing AutoDiffOperators\nusing LinearSolve: KrylovJL_CG\n\ncontext = MGVIContext(ADSelector(Zygote))","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Random.seed!(84612);\nnothing #hide","category":"page"},{"location":"advanced_tutorial/#Load-data","page":"Advanced Tutorial","title":"Load data","text":"","category":"section"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"The dataset, which is included with this repository, contains intervals in days between disasters occuring at British coal mines between March 1851 and March 1962. We build a model by splitting the entire time range into intervals of 365 days.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"function read_coal_mining_data(filepath, binsize)\n    init_year = empty\n    data = empty\n    open(filepath) do io\n        raw = readline(io)\n        while ! occursin(\"init_date\", raw)\n            raw = readline(io)\n        end\n\n        init_year = parse(Float64, split(split(strip(raw[2:end]), \"\\t\")[2], \"-\")[1])\n        data = readdlm(io, '\\t', Int, '\\n', comments=true)[:]\n    end\n    dates_fract_years = init_year .+ cumsum(data)/365\n    left_edge = dates_fract_years[1]\n    num_bins = ((dates_fract_years[end] - left_edge) ÷ binsize)\n    right_edge = left_edge + binsize*num_bins\n    fit(Histogram, dates_fract_years, left_edge:binsize:right_edge).weights\nend\n\ncoal_mine_disaster_data = read_coal_mining_data(joinpath(@__DIR__, \"coal_mining_data.tsv\"), 1);\nnothing #hide","category":"page"},{"location":"advanced_tutorial/#Global-parameters-and-the-grid","page":"Advanced Tutorial","title":"Global parameters and the grid","text":"","category":"section"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Now we define several model properties:","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"DATA_DIM is the shape of the dataset\nDATA_XLIM specifies the time range of the data\nGP_GRAIN_FACTOR determines the numbers of finer bins which a data bin is split into.  This is useful when there are several datasets defined on different grids.\nGP_PADDING adds empty paddings to the dataset. We use a Fourier transform to sample from the Gaussian process  with a finite correlation length. GP_PADDING helps us to ensure that periodic boundary conditions  imposed by a Fourier transform won't affect the data region.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"DATA_DIM = size(coal_mine_disaster_data, 1);\n\ndata = coal_mine_disaster_data;\n\nDATA_XLIM = [1851., 1962.];\n\nGP_GRAIN_FACTOR = 3;\nGP_PADDING = 80;\nnothing #hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"function produce_bins()\n    data_binsize = (DATA_XLIM[2] - DATA_XLIM[1])/DATA_DIM\n    gp_binsize = data_binsize/GP_GRAIN_FACTOR\n    gp_dim = Integer(((DATA_XLIM[2] - DATA_XLIM[1]) + 2*GP_PADDING) ÷ gp_binsize)\n    gp_left_bin_offset = gp_right_bin_offset = (gp_dim - DATA_DIM) ÷ 2\n    if (2*gp_left_bin_offset + DATA_DIM*GP_GRAIN_FACTOR) % 2 == 1\n        gp_left_bin_offset += 1\n    end\n    gp_left_xlim = DATA_XLIM[1] - gp_left_bin_offset*gp_binsize\n    gp_right_xlim = DATA_XLIM[2] + gp_right_bin_offset*gp_binsize\n    gp_left_xs = collect(gp_left_xlim + gp_binsize/2:gp_binsize:DATA_XLIM[1])\n    gp_right_xs = collect(DATA_XLIM[2] + gp_binsize/2:gp_binsize:gp_right_xlim)\n    gp_data_xs = collect(DATA_XLIM[1] + gp_binsize/2:gp_binsize:DATA_XLIM[2])\n    gp_xs = [gp_left_xs; gp_data_xs; gp_right_xs]\n    data_idxs = collect(gp_left_bin_offset+1:GP_GRAIN_FACTOR:gp_left_bin_offset+DATA_DIM*GP_GRAIN_FACTOR)\n    gp_xs, gp_binsize, data_idxs\nend;\nnothing #hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Based on the defined model properties, we generate the grid. GP grid is the fine-grained grid with offsets added to the data range.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"_GP_XS represent bin centers of such a fine-grained grid\n_GP_BINSIZE is the width of the bin (that is 1/GP_GRAIN_FACTOR of data bin size)\n_DATA_IDXS - integer indices of the left edges of the data bins","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"_GP_XS, _GP_BINSIZE, _DATA_IDXS = produce_bins();\n_GP_DIM = length(_GP_XS);\n_GP_HARMONIC_DIST = 1/_GP_DIM/_GP_BINSIZE;\nnothing #hide","category":"page"},{"location":"advanced_tutorial/#Model-parameters","page":"Advanced Tutorial","title":"Model parameters","text":"","category":"section"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"The Gaussian process in this tutorial is modeled in the Fourier space with zero mean and two hyperparameters defining properties of its kernel. To sample from this Gaussian process, we also need a parameter per bin that will represent the particular realization of the GP in the bin.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"function assemble_paridx(;kwargs...)\n    pos = 0\n    res = []\n    for (k, v) in kwargs\n        new_start, new_stop = v.start+pos, v.stop+pos\n        push!(res, (k, (v.start+pos):(v.stop+pos)))\n        pos = new_stop\n    end\n    (;res...)\nend;\nnothing #hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"MGVI is an iterative procedure, so we will need to introduce an initial guess for the state of the model. We create a vector with size equal to the count of all parameters' starting_point and a NamedTuple PARDIX that assigns names to the sub-regions in this vector. In the correct case:","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"gp_hyper is two hyperparameters of the Gaussian process stored in the first two cells of the parameter vector\ngp_latent _GP_DIM are parameters used to define the particular realization of the gaussian process,  stored at indices between 3 to 2 + _GP_DIM.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Function assemble_paridx is responsible for constructing such a NamedTuple from the parameter specification.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"PARIDX = assemble_paridx(gp_hyper=1:2, gp_latent=1:_GP_DIM);\n\nstarting_point = randn(last(PARIDX).stop);\nnothing #hide","category":"page"},{"location":"advanced_tutorial/#Model-implementation","page":"Advanced Tutorial","title":"Model implementation","text":"","category":"section"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"function map_idx(idx::Real, idx_range::AbstractUnitRange{<:Integer})\n    i = idx - minimum(idx_range)\n    n = length(eachindex(idx_range))\n    n_2 = n >> 1\n    ifelse(i <= n_2, i, i - n)\nend\n\nfunction dist_k(idx::CartesianIndex, ax::NTuple{N,<:AbstractUnitRange{<:Integer}}, harmonic_distances::NTuple{N,<:Real}) where N\n    mapped_idx = map(map_idx, Tuple(idx), ax)\n    norm(map(*, mapped_idx, harmonic_distances))\nend\n\nfunction dist_array(dims::NTuple{N,<:Real}, harmonic_distances::NTuple{N,<:Real}) where N\n    cart_idxs = CartesianIndices(map(Base.OneTo, dims))\n    dist_k.(cart_idxs, Ref(axes(cart_idxs)), Ref(harmonic_distances))\nend;\nnothing #hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"A Gaussian process's covariance in the Fourier space is represented with a diagonal matrix. Values on the diagonal follow a squared exponential function with parameters depending on priors. A kernel that is diagonal and mirrored around the center represents a periodic and translationally invariant function in the coordinate space. This property restricts covariance to have a finite correlation length in the coordinate space.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"The kernel in the Fourier space is defined on the domain of wave numbers k. We model the mirror-symmetrical kernel by imposing the mirror symmetry on the vector of the wave numbers. (See map_idx for the symmetry implementation)","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"k = dist_array((_GP_DIM,), (_GP_HARMONIC_DIST,));\nnothing #hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"MGVI assumes that all priors are distributed as standard normals N(0, 1); thus, to modify the shapes of the priors, we explicitly rescale them at the model implementation phase.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"We also exponentiate each prior before using it to tune the squared exponential shape. In doing so, we ensure only positive values for the kernel's hyperparameters.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Actually, for the sake of numeric stability we model already square root of the covariance. This can be traced by missing sqrt in the next level, where we sample from the Gaussian process.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"function amplitude_spectrum(d::Real, ampl::Real, corrlen::Real)\n    ampl * sqrt(2 * π * corrlen) * exp( -π^2 * d^2 * corrlen^2)\nend;\n\nfunction sqrt_kernel(p)\n    kernel_A_c, kernel_l_c = p[PARIDX.gp_hyper]\n    kernel_A = 2*exp(kernel_A_c*0.9)*GP_GRAIN_FACTOR\n    kernel_l = 12*exp(kernel_l_c/15)/(GP_GRAIN_FACTOR^0.3)\n    amplitude_spectrum.(k, kernel_A, kernel_l)\nend;\nnothing #hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"As a Fourier transform we choose the Discrete Hartley Transform, which ensures that Fourier coefficients of the real valued function remain real valued.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"ht = FFTW.plan_r2r(zeros(_GP_DIM), FFTW.DHT);\nnothing #hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Before we proceed, let's have a brief look at the kernel's shape. Below we plot the kernel in the coordinate space K(r) = K(x2 - x1) as a function of time in years between two points. As we go further along the x-axis, the time interval will increase, and the covariance will decrease.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"function plot_kernel_model(p, width; plot_args=(;))\n    xs = collect(1:Int(floor(width/_GP_BINSIZE)))\n    plot!(xs .* _GP_BINSIZE, (ht * (sqrt_kernel(p) .^ 2))[xs] .* _GP_HARMONIC_DIST, label=nothing, linewidth=2.5; plot_args...)\nend\n\nplot()\nplot_kernel_model(starting_point, 20)\nsavefig(\"advtut-plot1.pdf\")\nsavefig(\"advtut-plot1.svg\"); nothing # hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"(Image: Plot)","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"To make it even more visual, we also plot the structure of the covariance matrix as a heatmap. We see that the finite correlation length shows up as a band around the diagonal. We also see small artifacts in the antidiagonal corners. These come from the assumption that the kernel is periodic.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"function plot_kernel_matrix(p)\n    xkernel = ht * (sqrt_kernel(p) .^ 2) .* _GP_HARMONIC_DIST\n    res = reduce(hcat, [circshift(xkernel, i) for i in 0:(_GP_DIM-1)])'\n    heatmap!(_GP_XS, _GP_XS, res; yflip=true, xmirror=true, tick_direction=:out, top_margin=20px, right_margin=30px)\nend\n\nplot()\nplot_kernel_matrix(starting_point)\nsavefig(\"advtut-plot2.png\")","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"(Image: Plot)","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"After we defined the square root of the kernel function (sqrt_kernel), we just follow the regular procedure of sampling from the normal distribution. Since the covariance matrix in the Fourier space is diagonal, Gaussian variables in each bin are independent of each other. Thus, sampling ends up rescaling the gp_latent part of the prior vector responsible for the Gaussian process state.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"After we produced a sample of Gaussian random values following the kernel model, we apply a Fourier transform to return back to the coordinate space.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"function gp_sample(p)\n    flat_gp = sqrt_kernel(p) .* p[PARIDX.gp_latent]\n    (ht * flat_gp) .* _GP_HARMONIC_DIST\nend;\nnothing #hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Together with the implementation of gp_sample we also need to define its version of the Duals. This will allow our application of the Hartley transform to be differentiatiable.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"function gp_sample(dp::Vector{ForwardDiff.Dual{T, V, N}}) where {T,V,N}\n    flat_gp_duals = sqrt_kernel(dp) .* dp[PARIDX.gp_latent]\n    val_res = ht*ForwardDiff.value.(flat_gp_duals) .* _GP_HARMONIC_DIST\n    psize = size(ForwardDiff.partials(flat_gp_duals[1]), 1)\n    ps = x -> ForwardDiff.partials.(flat_gp_duals, x)\n    val_ps = map((x -> ht*ps(x) .* _GP_HARMONIC_DIST), 1:psize)\n    ForwardDiff.Dual{T}.(val_res, val_ps...)\nend;\nnothing #hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Gaussian process realization is meant to serve as a Poisson rate of the Poisson process. Since the Gaussian process is not restricted to positive values, we exponentiate its values to forcefully make the function positive.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"function poisson_gp_link(fs)\n    exp.(fs)\nend;\nnothing #hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Now when we have a function representing the Poisson rate density, we have to integrate it over each data bin to define the Poisson rate in these bins. Function agg_lambdas does precisely that. When GP_GRAIN_FACTOR = 1, this function just multiplies the value of the Gaussian process in the bin by the _GP_BINSIZE. When we have more GP bins per data bin (GP_GRAIN_FACTOR > 1), then we apply rectangular quadrature to integrate over the bin.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"function _forward_agg(data, idxs, steps_forward)\n    [sum(data[i:i+steps_forward-1]) for i in idxs]\nend;\n\nfunction agg_lambdas(lambdas)\n    gps = _forward_agg(lambdas, _DATA_IDXS, GP_GRAIN_FACTOR) .* _GP_BINSIZE\n    xs = _GP_XS[_DATA_IDXS .+ (GP_GRAIN_FACTOR ÷ 2)]\n    xs, gps\nend;\nnothing #hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Finally, we define the model by using the building blocks defined above:","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"gp_sample sample from the Gaussian process with defined sqrt_kernel covariance\npoisson_gp_link ensures Gaussian process is positive\nagg_lambdas integrates Gaussian process over each data bin to turn it into a Poisson rate for each bin\nmodel maps parameters into the product of the Poisson distribution's counting events in each bin.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"function model(params)\n    fs = gp_sample(params)\n    fine_lambdas = poisson_gp_link(fs)\n    _, lambdas = agg_lambdas(fine_lambdas)\n    product_distribution(fwddiff(Poisson).(lambdas))\nend;\nnothing #hide","category":"page"},{"location":"advanced_tutorial/#Visualization-utilities","page":"Advanced Tutorial","title":"Visualization utilities","text":"","category":"section"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"function agg_full_lambdas(lambdas)\n    left_idxs = 1:GP_GRAIN_FACTOR:(_DATA_IDXS[1]-GP_GRAIN_FACTOR)\n    left_gp = _forward_agg(lambdas, left_idxs, GP_GRAIN_FACTOR) .* _GP_BINSIZE\n    left_xs = _GP_XS[left_idxs .+ (GP_GRAIN_FACTOR ÷ 2)]\n    right_idxs = (_DATA_IDXS[end]+1):GP_GRAIN_FACTOR:(size(lambdas, 1) - GP_GRAIN_FACTOR)\n    right_gp = _forward_agg(lambdas, right_idxs, GP_GRAIN_FACTOR) .* _GP_BINSIZE\n    right_xs = _GP_XS[right_idxs .+ (GP_GRAIN_FACTOR ÷ 2)]\n    middle_xs, middle_gp = agg_lambdas(lambdas)\n    full_xs = [left_xs; middle_xs; right_xs]\n    full_gp = [left_gp; middle_gp; right_gp]\n    full_xs, full_gp\nend;\n\nfunction _mean(p; full=false)\n    agg_func = if (!full) agg_lambdas else agg_full_lambdas end\n    xs, gps = agg_func(poisson_gp_link(gp_sample(p)))\n    xs, gps\nend;\n\nfunction plot_mean(p, label=\"mean\"; plot_args=(;), full=false)\n    plot!(_mean(p; full=full)...; label=label, linewidth=3, plot_args...)\nend;\n\nfunction plot_prior_samples(num_samples; mean_plot_args=(;))\n    for _ in 1:num_samples\n        p = randn(last(PARIDX).stop)\n        plot_mean(p, nothing; plot_args=mean_plot_args)\n    end\nend;\n\nfunction plot_kernel_prior_samples(num_samples, width)\n    for _ in 1:num_samples\n        p = randn(last(PARIDX).stop)\n        plot_kernel_model(p, width)\n    end\n    plot!()\nend;\n\nfunction plot_data(; scatter_args=(;), smooth_args=(;))\n    bar!(_GP_XS[_DATA_IDXS .+ (GP_GRAIN_FACTOR ÷ 2)], data, color=:deepskyblue2, la=0, markersize=2., markerstrokewidth=0, alpha=0.4, label=\"data\"; scatter_args...)\n    smooth_step = 4\n    smooth_xs = _GP_XS[_DATA_IDXS .+ (GP_GRAIN_FACTOR ÷ 2)][(smooth_step+1):(end-smooth_step)]\n    smooth_data = [sum(data[i-smooth_step:i+smooth_step])/(2*smooth_step+1) for i in (smooth_step+1):(size(data, 1)-smooth_step)]\n    plot!(smooth_xs, smooth_data, color=:deeppink3, linewidth=3, linealpha=1, ls=:dash, label=\"smooth data\"; smooth_args...)\nend;\n\nfunction plot_mgvi_samples(samples)\n    for sample in eachcol(samples)\n        if any(isnan.(sample))\n            print(\"nan found in samples\", \"\\n\")\n            continue\n        end\n        plot!(_mean(Vector(sample))..., linealpha=0.5, linewidth=2, label=nothing)\n    end\n    plot!()\nend;\n\nfunction plot_kernel_mgvi_samples(samples, width)\n    for sample in eachcol(samples)\n        if any(isnan.(sample))\n            print(\"nan found in samples\", \"\\n\")\n            continue\n        end\n        plot_kernel_model(sample, width; plot_args=(linealpha=0.5, linewidth=2, label=nothing))\n    end\n    plot!()\nend;\n\nfunction produce_posterior_samples(p, num_residuals)\n    batch_size = 10\n\n    if num_residuals <= 2*batch_size\n        batch_size = num_residuals ÷ 2\n    end\n\n    est_res_sampler = MGVI.ResidualSampler(\n        model, p, KrylovJL_CG((atol=1E-2,)), context\n    )\n    batches = []\n    for _ in 1:(num_residuals ÷ batch_size ÷ 2)\n        batch_residual_samples = MGVI.sample_residuals(est_res_sampler, batch_size)\n        push!(batches, p .+ batch_residual_samples)\n        push!(batches, p .- batch_residual_samples)\n    end\n    reduce(hcat, batches)\nend\n\nfunction _extract_quantile(sorted_gp_realizations, p)\n    map(s -> quantile(s, p; sorted=true), eachrow(sorted_gp_realizations))\nend;\n\nfunction plot_posterior_bands(p, num_samples; full=false)\n    bands = [(0.997, :red), (0.955, :goldenrod1), (0.683, :green)]\n    samples = produce_posterior_samples(p, num_samples)\n    xs, first_gp = _mean(samples[1:end, 1]; full=full)\n    gp_realizations = reduce(hcat, [_mean(Vector(sample); full=full)[2] for sample in eachcol(samples[1:end, 2:end])]; init=first_gp)\n    for (i, one_x_sample) in enumerate(eachrow(gp_realizations))\n        gp_realizations[i, 1:end] .= sort(Vector(one_x_sample))\n    end\n    for (band, color) in bands\n        quant_l = _extract_quantile(gp_realizations, (1-band)/2)\n        quant_u = _extract_quantile(gp_realizations, (1+band)/2)\n        plot!(xs, quant_l; fillrange=quant_u, fillcolor=color, linealpha=0, label=band)\n    end\n    sample_median = _extract_quantile(gp_realizations, 0.5)\n    plot!(xs, sample_median; linewidth=2, linecolor=:grey25, label=\"median\")\nend;\nnothing #hide","category":"page"},{"location":"advanced_tutorial/#Visualization-and-fitting","page":"Advanced Tutorial","title":"Visualization and fitting","text":"","category":"section"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"We start by plotting the Gaussian process's dynamic range by sampling many possible realizations of it unconditionally on the data. We expect the set of lines to populate the regions where there are data.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"plot()\nplot_data(;scatter_args=(;alpha=0.7))\nplot_prior_samples(200, mean_plot_args=(;alpha=0.5))\nplot!(ylim=[0, 8])\nsavefig(\"advtut-plot3.png\")","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"(Image: Plot)","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"We also plot prior samples for the kernel in the coordinate space. The plot below shows that the kernel is flexible in the amplitude while the correlation length is quite strongly predefined:","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"plot()\nplot_kernel_prior_samples(200, 20)\nsavefig(\"advtut-plot4.pdf\")\nsavefig(\"advtut-plot4.svg\"); nothing # hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"(Image: Plot)","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Now that we see that the Gaussian process is potentially able to fit the data, we plot the initial guess (starting_point) to see where we should start from. This plot shows:","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"data points\nsmoothed data with a moving average of 9 years\nPoisson rate for each bin\nMGVI samples around the mean. At the later stages they can be used to estimate MGVI's uncertainty","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"plot()\nplot_data()\nplot_mean(starting_point, \"starting point\"; plot_args=(;color=:darkorange2))\nplot_mgvi_samples(produce_posterior_samples(starting_point, 6))\nsavefig(\"advtut-plot5.pdf\")\nsavefig(\"advtut-plot5.svg\"); nothing # hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"(Image: Plot)","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"We also want to introduce the full plot that shows not only the data region, but includes the region with the padding we added with GP_PADDING. We will use this plot to make sure that periodic boundary conditions don't interfere with the data.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"plot()\nplot_data()\nplot_mean(starting_point, \"full gp\"; full=true, plot_args=(;color=:pink))\nplot_mean(starting_point, \"starting point\"; plot_args=(;color=:darkorange2))\nsavefig(\"advtut-plot6.pdf\")\nsavefig(\"advtut-plot6.svg\"); nothing # hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"(Image: Plot)","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Below we also plot the kernel and MGVI samples that represent the possible variation of the kernel shape around the mean:","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"plot()\nplot_kernel_model(starting_point, 20; plot_args=(;label=\"kernel model\"))\nplot_kernel_mgvi_samples(produce_posterior_samples(starting_point, 6), 20)\nsavefig(\"advtut-plot7.pdf\")\nsavefig(\"advtut-plot7.svg\"); nothing # hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"(Image: Plot)","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Let's make a first iteration of the MGVI. For purposes of displaying the convergence curve, we limit the optimization to 1 step so that MGVI will coverge more slowly.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"config = MGVIConfig(\n    linsolver = KrylovJL_CG((;itmax=10)),\n    optimizer = MGVI.NewtonCG(steps = 1)\n)\nresult, center_point = mgvi_step(model, data, 3, starting_point, config, context);\nnothing #hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"We again plot data and the Poisson rate. We again show the Gaussian process with padding. After one iteration the Poisson rate doesn't seem to get much closer to the data.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"plot()\nplot_data()\nplot_mean(center_point, \"first iteration\"; plot_args=(;color=:darkorange2))\nplot_mgvi_samples(result.samples)\nsavefig(\"advtut-plot8.pdf\")\nsavefig(\"advtut-plot8.svg\"); nothing # hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"(Image: Plot)","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"plot()\nplot_data()\nplot_mean(center_point, \"full gp\"; full=true, plot_args=(;color=:pink))\nplot_mean(center_point, \"first iteration\"; plot_args=(;color=:darkorange2))\nsavefig(\"advtut-plot9.pdf\")\nsavefig(\"advtut-plot9.svg\"); nothing # hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"(Image: Plot)","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Kernel and its MGVI samples changed significantly in comparison to the starting_point even after the first iteration:","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"plot()\nplot_kernel_model(center_point, 20; plot_args=(;label=\"kernel model\"))\nplot_kernel_mgvi_samples(result.samples, 20)\nsavefig(\"advtut-plot10.pdf\")\nsavefig(\"advtut-plot10.svg\"); nothing # hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"(Image: Plot)","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"In order to visualize convergence we prepare a few functions to compute, store and plot the average posterior likelihood of.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"function compute_avg_likelihood(model, samples, data)\n    tot = 0\n    for sample in eachcol(samples)\n        tot += -MGVI.posterior_loglike(model, sample, data)\n    end\n    tot/size(samples, 2)\nend;\n\nfunction show_avg_likelihood(series)\n    scatter!(1:size(series, 1), series, label=\"-loglike\")\nend;\nnothing #hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Now we do 30 more iterations of the MGVI and store the average likelihood after each step. We feed the fitted result of the previous step as an input to the next iteration.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"config = MGVIConfig(\n    linsolver = KrylovJL_CG((;atol=1E-2,verbose=false)),\n    optimizer = MGVI.NewtonCG()\n)\n\navg_likelihood_series = [];\npush!(avg_likelihood_series, compute_avg_likelihood(model, result.samples, data));\nfor i in 1:30\n    global result, center_point = mgvi_step(model, data, 3, center_point, config, context);\n    push!(avg_likelihood_series, compute_avg_likelihood(model, result.samples, data))\nend;\nnothing #hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"First, let's have a look at the convergence plots. We see that MGVI converged after 10 iterations while being limited to very poor Optim performance.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"plot(yscale=:log)\nshow_avg_likelihood(avg_likelihood_series)\nsavefig(\"advtut-plot11.pdf\")\nsavefig(\"advtut-plot11.svg\"); nothing # hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"(Image: Plot)","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Below we plot the result of the fit. Together with the data and Poisson rate, we also plot MGVI residuals. These are samples from the Gaussian posterior, sampled with respect to the posterior's covariance structure. Thus MGVI residual samples are deviations from the MGVI fit and represent how confident we are about the prediction.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"plot(ylim=[0,8])\nplot_data()\nplot_mgvi_samples(result.samples)\nplot_mean(center_point, \"many iterations\"; plot_args=(;color=:darkorange2))\nsavefig(\"advtut-plot12.pdf\")\nsavefig(\"advtut-plot12.svg\"); nothing # hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"(Image: Plot)","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"To present credibility intervals we also plot credibility bands. We sample 400 residual samples from MGVI and then plot quantiles for each data bin. This should give us a feeling of how compatible the MGVI fit is with the data.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"plot(ylim=[0,8])\nplot_posterior_bands(center_point, 400)\nplot_data()\nplot_mean(center_point, \"many iterations\"; plot_args=(;color=:darkorange2))\nsavefig(\"advtut-plot13.pdf\")\nsavefig(\"advtut-plot13.svg\"); nothing # hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"(Image: Plot) We also make sure boundary conditions do not interfere with the data. Here is the Gaussian process plot with the paddings included:","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"plot()\nplot_data()\nplot_mean(center_point; full=true, plot_args=(;color=:pink))\nplot_mean(center_point, \"many iterations\"; plot_args=(;color=:darkorange2))\nsavefig(\"advtut-plot14.pdf\")\nsavefig(\"advtut-plot14.svg\"); nothing # hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"(Image: Plot)","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Let's have a look at the kernel again. We expect the variation of samples to become narrower:","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"plot()\nplot_kernel_model(center_point, 20; plot_args=(;label=\"kernel model\"))\nplot_kernel_mgvi_samples(result.samples, 20)\nsavefig(\"advtut-plot15.pdf\")\nsavefig(\"advtut-plot15.svg\"); nothing # hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"(Image: Plot)","category":"page"},{"location":"advanced_tutorial/#Maximum-a-posteriori-estimation","page":"Advanced Tutorial","title":"Maximum a posteriori estimation","text":"","category":"section"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"We build a MAP as a cross check of MGVI results. We simply optimize the posterior likelihood by using Optim without any particular tuning settings:","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"max_posterior = Optim.optimize(x -> -MGVI.posterior_loglike(model, x, data), starting_point, LBFGS(), Optim.Options(show_trace=false, g_tol=1E-6, iterations=30));\nnothing #hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"We observe that the bump in the middle (around 1910) is caught by the MAP while it is less pronounced in the MGVI fit. MAP also has finer structure around 1875 and 1835.","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"plot()\nplot_data()\nplot_mean(center_point, \"mgvi mean\"; plot_args=(;color=:darkorange2))\nplot_mean(Optim.minimizer(max_posterior), \"map\")\nsavefig(\"advtut-plot16.pdf\")\nsavefig(\"advtut-plot16.svg\"); nothing # hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"(Image: Plot)","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"We also can see the difference at the left edge of the data region. While MGVI smoothed the data, the MAP predicted a consequent peak:","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"plot()\nplot_data()\nplot_mean(Optim.minimizer(max_posterior), \"full gp\"; full=true, plot_args=(;color=:darkorange2))\nplot_mean(center_point, \"mgvi full gp\"; full=true)\nsavefig(\"advtut-plot17.pdf\")\nsavefig(\"advtut-plot17.svg\"); nothing # hide","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"(Image: Plot)","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"","category":"page"},{"location":"advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#MGVI.jl","page":"Home","title":"MGVI.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MGVI is an iterative method that performs a series of Gaussian approximations to the posterior. We alternate between approximating the covariance with the inverse Fisher information metric evaluated at an intermediate mean estimate and optimizing the KL-divergence for the given covariance with respect to the mean. This procedure is iterated until the uncertainty estimate is self-consistent with the mean parameter. We achieve linear scaling by avoiding to store the covariance explicitly at any time. Instead we draw samples from the approximating distribution relying on an implicit representation and numerical schemes to approximately solve linear equations. Those samples are used to approximate the KL-divergence and its gradient. The usage of natural gradient descent allows for rapid convergence. Formulating the Bayesian model in standardized coordinates makes MGVI applicable to any inference problem with continuous parameters. ","category":"page"},{"location":"#Citing-MGVI.jl","page":"Home","title":"Citing MGVI.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When using MGVI.jl for research, teaching or similar, please cite this publication: Metric Gaussian Variational Inference","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{knollmüller2020metric,\n         title={Metric Gaussian Variational Inference},\n         author={Jakob Knollmüller and Torsten A. Enßlin},\n         year={2020},\n         eprint={1901.11033},\n         archivePrefix={arXiv},\n         primaryClass={stat.ML}\n}","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also download this tutorial as a Jupyter notebook and a plain Julia source file.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using MGVI","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Distributions\nusing Random\nusing ValueShapes\nusing LinearAlgebra\n\nimport Zygote\nusing AutoDiffOperators\nusing LinearSolve: KrylovJL_CG","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We want to fit a 3-degree polynomial using two data sets (a and b). MGVI requires a model expressed as a function of the model parameters and returning an instance of the Distribution. In this example, since we have two sets of independent measurements, we express them as ValueShapes.NamedTupleDist.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We assume errors are normally distributed with unknown covariance, which has to be learned as well.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"context = MGVIContext(ADSelector(Zygote))\n\nconst _x1_grid = [Float64(i)/10 for i in 1:25]\nconst _x2_grid = [Float64(i)/10 + 0.1 for i in 1:15]\nconst _common_grid = sort(vcat(_x1_grid, _x2_grid))\n\nfunction _mean(x_grid, p)\n    p[1]*10 .+ p[2]*40 .* x_grid .+ p[3]*600 .* x_grid.^2 .+ p[4]*80 .* x_grid.^3\nend\n\nfunction model(p)\n    dist1 = product_distribution(Normal.(_mean(_x1_grid, p), p[5]^2*60))\n    dist2 = product_distribution(Normal.(_mean(_x2_grid, p), p[5]^2*60))\n    NamedTupleDist(a=dist1,\n                   b=dist2)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we define the ground truth of the parameters, as well as an initial guess.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"const true_params =  [\n -0.3\n -1.5\n 0.2\n -0.5\n 0.3]\n\nconst starting_point = [\n  0.2\n  0.5\n  -0.1\n  0.3\n -0.6\n];\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function pprintln(obj)\n    show(stdout, \"text/plain\", obj)\n    println()\nend;\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rng = MersenneTwister(157);\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We draw data directly from the model, using the true parameter values:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"data = rand(rng, model(true_params), 1)[1];\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function _mean(x::Vector)\n    _mean(_common_grid, x)\nend\n\ninit_plots =() -> let\n    truth = _mean(true_params)\n    plot!(_common_grid, truth, markercolor=:blue, linecolor=:blue, label=\"truth\")\n    scatter!(_common_grid, _mean(starting_point), markercolor=:orange, markerstrokewidth=0, markersize=3, label=\"init\")\n    scatter!(vcat(_x1_grid, _x2_grid), reduce(vcat, data), markercolor=:black, markerstrokewidth=0, markersize=3, label=\"data\")\nend;\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Before we start the optimization, let's have an initial look at the data. It is also interesting to see how our starting guess performs.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"p = plot()\ninit_plots()\nsavefig(\"tutorial-plot1.pdf\")\nsavefig(\"tutorial-plot1.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Plot)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we are ready to run one iteration of the MGVI. The output contains an updated parameter estimate (center_point), which we can compare to the true parameters.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"config = MGVIConfig(\n    linsolver = KrylovJL_CG((;itmax=10)),\n    optimizer = MGVI.NewtonCG()\n)\nresult, center_point = mgvi_step(model, data, 3, starting_point, config, context)\n@info hcat(center_point, true_params)\np\nsavefig(\"tutorial-plot2.pdf\")\nsavefig(\"tutorial-plot2.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Plot)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot_iteration = (result, center_point, label) -> let\n    #error_mat = mgvi_kl_errors(full_model, params)\n    #display(error_mat)\n    #errors = sqrt.(error_mat[diagind(error_mat)])\n    #yerr = abs.(line(common_grid, params+errors) - line(common_grid, params-errors))\n    #scatter!(common_grid, line(common_grid, params), markercolor=:green, label=label, yerr=yerr)\n    for sample in eachcol(result.samples)\n        scatter!(_common_grid, _mean(Vector(sample)), markercolor=:gray, markeralpha=0.3, markersize=2, label=nothing)\n    end\n    scatter!(_common_grid, _mean(center_point), markercolor=:green, label=label)\nend;\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now let's also plot the curve corresponding to the new parameters after the first iteration:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"p = plot()\ninit_plots()\nplot_iteration(result, center_point, \"first\")\np\nsavefig(\"tutorial-3.pdf\")\nsavefig(\"tutorial-3.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Plot)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot_iteration_light = (center_point, counter) -> let\n    scatter!(_common_grid, _mean(center_point), markercolor=:green, markersize=3, markeralpha=2*atan(counter/18)/π, label=nothing)\nend;\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"From the plot above we see that one iteration is not enough. Let's do 5 more steps and plot the evolution of estimates.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"config = MGVIConfig(\n    linsolver = KrylovJL_CG((;itmax=10)),\n    optimizer = MGVI.NewtonCG()\n)\n\ninit_plots()\nplt = scatter()\nfor i in 1:5\n    @info result.mnlp\n    @info hcat(center_point, true_params)\n    global result, center_point = mgvi_step(model, data, 10, center_point, config, context)\n    plot_iteration_light(center_point, i)\nend\n@info minimum(result.mnlp)\n@info hcat(center_point, true_params)\nplt\nsavefig(\"tutorial-plot4.pdf\")\nsavefig(\"tutorial-plot4.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Plot)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, let's plot the last estimate and compare it to the truth. Also, notice, that gray dots represent samples from the approximation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"p = plot()\ninit_plots()\nplot_iteration(result, center_point, \"last\")\np\nsavefig(\"tutorial-5.pdf\")\nsavefig(\"tutorial-5.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Plot)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}
