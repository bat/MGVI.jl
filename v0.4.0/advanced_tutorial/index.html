<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advanced Tutorial · MGVI</title><meta name="title" content="Advanced Tutorial · MGVI"/><meta property="og:title" content="Advanced Tutorial · MGVI"/><meta property="twitter:title" content="Advanced Tutorial · MGVI"/><meta name="description" content="Documentation for MGVI."/><meta property="og:description" content="Documentation for MGVI."/><meta property="twitter:description" content="Documentation for MGVI."/><meta property="og:url" content="https://bat.github.io/MGVI.jl/stable/advanced_tutorial/"/><meta property="twitter:url" content="https://bat.github.io/MGVI.jl/stable/advanced_tutorial/"/><link rel="canonical" href="https://bat.github.io/MGVI.jl/stable/advanced_tutorial/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MGVI</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Advanced Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Prepare-the-environment"><span>Prepare the environment</span></a></li><li><a class="tocitem" href="#Load-data"><span>Load data</span></a></li><li><a class="tocitem" href="#Global-parameters-and-the-grid"><span>Global parameters and the grid</span></a></li><li><a class="tocitem" href="#Model-parameters"><span>Model parameters</span></a></li><li><a class="tocitem" href="#Model-implementation"><span>Model implementation</span></a></li><li><a class="tocitem" href="#Visualization-utilities"><span>Visualization utilities</span></a></li><li><a class="tocitem" href="#Visualization-and-fitting"><span>Visualization and fitting</span></a></li><li><a class="tocitem" href="#Maximum-a-posteriori-estimation"><span>Maximum a posteriori estimation</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../LICENSE/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Advanced Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Advanced Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/bat/MGVI.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/bat/MGVI.jl/blob/main/docs/src/advanced_tutorial_lit.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Advanced-Tutorial"><a class="docs-heading-anchor" href="#Advanced-Tutorial">Advanced Tutorial</a><a id="Advanced-Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Tutorial" title="Permalink"></a></h1><p>You can also download this tutorial as a <a href="../mgvi_advanced_tutorial.ipynb">Jupyter notebook</a> and a plain <a href="../mgvi_advanced_tutorial.jl">Julia source file</a>.</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>In this tutorial, we will fit the <a href="../coal_mining_data.tsv">coal mining disaster dataset</a> with a Gaussian process modulated Poisson process.</p><h2 id="Prepare-the-environment"><a class="docs-heading-anchor" href="#Prepare-the-environment">Prepare the environment</a><a id="Prepare-the-environment-1"></a><a class="docs-heading-anchor-permalink" href="#Prepare-the-environment" title="Permalink"></a></h2><p>We start by importing:</p><ul><li>MGVI for the posterior fit</li><li><code>Distributions.jl</code> and <code>FFTW.jl</code> to define the statistical model</li><li><code>Optim.jl</code> to pass <code>Optim.Options</code> to MGVI and to find Maximum a posteriori fit that we will use for comparison</li><li><code>StatsBase.jl</code> for histogram construction from the data and also for error bands visualization</li><li><code>Plots.jl</code> for visualization</li></ul><pre><code class="language-julia hljs">using MGVI

using FillArrays
using DelimitedFiles
using LinearAlgebra
using Random
using StatsBase
using Distributions
using Optim
using ForwardDiffPullbacks

using Plots
using Plots.PlotMeasures
Plots.default(legendfontsize=10, tickfontsize=10, grid=false, dpi=120, size=(500, 300))

using FFTW

import ForwardDiff, Zygote
using AutoDiffOperators
using LinearSolve: KrylovJL_CG

context = MGVIContext(ADSelector(Zygote))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MGVIContext{HeterogeneousComputing.GenContext{Float64, HeterogeneousComputing.CPUnit, Random.TaskLocalRNG}, ADTypes.AutoZygote}(HeterogeneousComputing.GenContext{Float64, HeterogeneousComputing.CPUnit, Random.TaskLocalRNG}(HeterogeneousComputing.CPUnit(), Random.TaskLocalRNG()), ADTypes.AutoZygote())</code></pre><pre><code class="language-julia hljs">Random.seed!(84612);</code></pre><h2 id="Load-data"><a class="docs-heading-anchor" href="#Load-data">Load data</a><a id="Load-data-1"></a><a class="docs-heading-anchor-permalink" href="#Load-data" title="Permalink"></a></h2><p>The dataset, which is included with this repository, contains intervals in days between disasters occuring at British coal mines between March 1851 and March 1962. We build a model by splitting the entire time range into intervals of 365 days.</p><pre><code class="language-julia hljs">function read_coal_mining_data(filepath, binsize)
    init_year = empty
    data = empty
    open(filepath) do io
        raw = readline(io)
        while ! occursin(&quot;init_date&quot;, raw)
            raw = readline(io)
        end

        init_year = parse(Float64, split(split(strip(raw[2:end]), &quot;\t&quot;)[2], &quot;-&quot;)[1])
        data = readdlm(io, &#39;\t&#39;, Int, &#39;\n&#39;, comments=true)[:]
    end
    dates_fract_years = init_year .+ cumsum(data)/365
    left_edge = dates_fract_years[1]
    num_bins = ((dates_fract_years[end] - left_edge) ÷ binsize)
    right_edge = left_edge + binsize*num_bins
    fit(Histogram, dates_fract_years, left_edge:binsize:right_edge).weights
end

coal_mine_disaster_data = read_coal_mining_data(joinpath(@__DIR__, &quot;coal_mining_data.tsv&quot;), 1);</code></pre><h2 id="Global-parameters-and-the-grid"><a class="docs-heading-anchor" href="#Global-parameters-and-the-grid">Global parameters and the grid</a><a id="Global-parameters-and-the-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Global-parameters-and-the-grid" title="Permalink"></a></h2><p>Now we define several model properties:</p><ul><li><code>DATA_DIM</code> is the shape of the dataset</li><li><code>DATA_XLIM</code> specifies the time range of the data</li><li><code>GP_GRAIN_FACTOR</code> determines the numbers of finer bins which a data bin is split into.  This is useful when there are several datasets defined on different grids.</li><li><code>GP_PADDING</code> adds empty paddings to the dataset. We use a Fourier transform to sample from the Gaussian process  with a finite correlation length. <code>GP_PADDING</code> helps us to ensure that periodic boundary conditions  imposed by a Fourier transform won&#39;t affect the data region.</li></ul><pre><code class="language-julia hljs">DATA_DIM = size(coal_mine_disaster_data, 1);

data = coal_mine_disaster_data;

DATA_XLIM = [1851., 1962.];

GP_GRAIN_FACTOR = 3;
GP_PADDING = 80;</code></pre><pre><code class="language-julia hljs">function produce_bins()
    data_binsize = (DATA_XLIM[2] - DATA_XLIM[1])/DATA_DIM
    gp_binsize = data_binsize/GP_GRAIN_FACTOR
    gp_dim = Integer(((DATA_XLIM[2] - DATA_XLIM[1]) + 2*GP_PADDING) ÷ gp_binsize)
    gp_left_bin_offset = gp_right_bin_offset = (gp_dim - DATA_DIM) ÷ 2
    if (2*gp_left_bin_offset + DATA_DIM*GP_GRAIN_FACTOR) % 2 == 1
        gp_left_bin_offset += 1
    end
    gp_left_xlim = DATA_XLIM[1] - gp_left_bin_offset*gp_binsize
    gp_right_xlim = DATA_XLIM[2] + gp_right_bin_offset*gp_binsize
    gp_left_xs = collect(gp_left_xlim + gp_binsize/2:gp_binsize:DATA_XLIM[1])
    gp_right_xs = collect(DATA_XLIM[2] + gp_binsize/2:gp_binsize:gp_right_xlim)
    gp_data_xs = collect(DATA_XLIM[1] + gp_binsize/2:gp_binsize:DATA_XLIM[2])
    gp_xs = [gp_left_xs; gp_data_xs; gp_right_xs]
    data_idxs = collect(gp_left_bin_offset+1:GP_GRAIN_FACTOR:gp_left_bin_offset+DATA_DIM*GP_GRAIN_FACTOR)
    gp_xs, gp_binsize, data_idxs
end;</code></pre><p>Based on the defined model properties, we generate the grid. GP grid is the fine-grained grid with offsets added to the data range.</p><ul><li><code>_GP_XS</code> represent bin centers of such a fine-grained grid</li><li><code>_GP_BINSIZE</code> is the width of the bin (that is 1/<code>GP_GRAIN_FACTOR</code> of data bin size)</li><li><code>_DATA_IDXS</code> - integer indices of the left edges of the data bins</li></ul><pre><code class="language-julia hljs">_GP_XS, _GP_BINSIZE, _DATA_IDXS = produce_bins();
_GP_DIM = length(_GP_XS);
_GP_HARMONIC_DIST = 1/_GP_DIM/_GP_BINSIZE;</code></pre><h2 id="Model-parameters"><a class="docs-heading-anchor" href="#Model-parameters">Model parameters</a><a id="Model-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Model-parameters" title="Permalink"></a></h2><p>The Gaussian process in this tutorial is modeled in the Fourier space with zero mean and two hyperparameters defining properties of its kernel. To sample from this Gaussian process, we also need a parameter per bin that will represent the particular realization of the GP in the bin.</p><pre><code class="language-julia hljs">function assemble_paridx(;kwargs...)
    pos = 0
    res = []
    for (k, v) in kwargs
        new_start, new_stop = v.start+pos, v.stop+pos
        push!(res, (k, (v.start+pos):(v.stop+pos)))
        pos = new_stop
    end
    (;res...)
end;</code></pre><p>MGVI is an iterative procedure, so we will need to introduce an initial guess for the state of the model. We create a vector with size equal to the count of all parameters&#39; <code>starting_point</code> and a NamedTuple <code>PARDIX</code> that assigns names to the sub-regions in this vector. In the correct case:</p><ul><li><code>gp_hyper</code> is two hyperparameters of the Gaussian process stored in the first two cells of the parameter vector</li><li><code>gp_latent</code> <code>_GP_DIM</code> are parameters used to define the particular realization of the gaussian process,  stored at indices between <code>3</code> to <code>2 + _GP_DIM</code>.</li></ul><p>Function <code>assemble_paridx</code> is responsible for constructing such a NamedTuple from the parameter specification.</p><pre><code class="language-julia hljs">PARIDX = assemble_paridx(gp_hyper=1:2, gp_latent=1:_GP_DIM);

starting_point = randn(last(PARIDX).stop);</code></pre><h2 id="Model-implementation"><a class="docs-heading-anchor" href="#Model-implementation">Model implementation</a><a id="Model-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Model-implementation" title="Permalink"></a></h2><pre><code class="language-julia hljs">function map_idx(idx::Real, idx_range::AbstractUnitRange{&lt;:Integer})
    i = idx - minimum(idx_range)
    n = length(eachindex(idx_range))
    n_2 = n &gt;&gt; 1
    ifelse(i &lt;= n_2, i, i - n)
end

function dist_k(idx::CartesianIndex, ax::NTuple{N,&lt;:AbstractUnitRange{&lt;:Integer}}, harmonic_distances::NTuple{N,&lt;:Real}) where N
    mapped_idx = map(map_idx, Tuple(idx), ax)
    norm(map(*, mapped_idx, harmonic_distances))
end

function dist_array(dims::NTuple{N,&lt;:Real}, harmonic_distances::NTuple{N,&lt;:Real}) where N
    cart_idxs = CartesianIndices(map(Base.OneTo, dims))
    dist_k.(cart_idxs, Ref(axes(cart_idxs)), Ref(harmonic_distances))
end;</code></pre><p>A Gaussian process&#39;s covariance in the Fourier space is represented with a diagonal matrix. Values on the diagonal follow a squared exponential function with parameters depending on priors. A kernel that is diagonal and mirrored around the center represents a periodic and translationally invariant function in the coordinate space. This property restricts covariance to have a finite correlation length in the coordinate space.</p><p>The kernel in the Fourier space is defined on the domain of wave numbers <code>k</code>. We model the mirror-symmetrical kernel by imposing the mirror symmetry on the vector of the wave numbers. (See <code>map_idx</code> for the symmetry implementation)</p><pre><code class="language-julia hljs">k = dist_array((_GP_DIM,), (_GP_HARMONIC_DIST,));</code></pre><p>MGVI assumes that all priors are distributed as standard normals <code>N(0, 1)</code>; thus, to modify the shapes of the priors, we explicitly rescale them at the model implementation phase.</p><p>We also exponentiate each prior before using it to tune the squared exponential shape. In doing so, we ensure only positive values for the kernel&#39;s hyperparameters.</p><p>Actually, for the sake of numeric stability we model already square root of the covariance. This can be traced by missing <code>sqrt</code> in the next level, where we sample from the Gaussian process.</p><pre><code class="language-julia hljs">function amplitude_spectrum(d::Real, ampl::Real, corrlen::Real)
    ampl * sqrt(2 * π * corrlen) * exp( -π^2 * d^2 * corrlen^2)
end;

function sqrt_kernel(p)
    kernel_A_c, kernel_l_c = p[PARIDX.gp_hyper]
    kernel_A = 2*exp(kernel_A_c*0.9)*GP_GRAIN_FACTOR
    kernel_l = 12*exp(kernel_l_c/15)/(GP_GRAIN_FACTOR^0.3)
    amplitude_spectrum.(k, kernel_A, kernel_l)
end;</code></pre><p>As a Fourier transform we choose the Discrete Hartley Transform, which ensures that Fourier coefficients of the real valued function remain real valued.</p><pre><code class="language-julia hljs">ht = FFTW.plan_r2r(zeros(_GP_DIM), FFTW.DHT);</code></pre><p>Before we proceed, let&#39;s have a brief look at the kernel&#39;s shape. Below we plot the kernel in the coordinate space <code>K(r) = K(x2 - x1)</code> as a function of time in years between two points. As we go further along the <code>x</code>-axis, the time interval will increase, and the covariance will decrease.</p><pre><code class="language-julia hljs">function plot_kernel_model(p, width; plot_args=(;))
    xs = collect(1:Int(floor(width/_GP_BINSIZE)))
    plot!(xs .* _GP_BINSIZE, (ht * (sqrt_kernel(p) .^ 2))[xs] .* _GP_HARMONIC_DIST, label=nothing, linewidth=2.5; plot_args...)
end

plot()
plot_kernel_model(starting_point, 20)
savefig(&quot;advtut-plot1.pdf&quot;)</code></pre><p><a href="../advtut-plot1.pdf"><img src="../advtut-plot1.svg" alt="Plot"/></a></p><p>To make it even more visual, we also plot the structure of the covariance matrix as a heatmap. We see that the finite correlation length shows up as a band around the diagonal. We also see small artifacts in the antidiagonal corners. These come from the assumption that the kernel is periodic.</p><pre><code class="language-julia hljs">function plot_kernel_matrix(p)
    xkernel = ht * (sqrt_kernel(p) .^ 2) .* _GP_HARMONIC_DIST
    res = reduce(hcat, [circshift(xkernel, i) for i in 0:(_GP_DIM-1)])&#39;
    heatmap!(_GP_XS, _GP_XS, res; yflip=true, xmirror=true, tick_direction=:out, top_margin=20px, right_margin=30px)
end

plot()
plot_kernel_matrix(starting_point)
savefig(&quot;advtut-plot2.png&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;/home/runner/work/MGVI.jl/MGVI.jl/docs/build/advtut-plot2.png&quot;</code></pre><p><a href="../advtut-plot2.png"><img src="../advtut-plot2.png" alt="Plot"/></a></p><p>After we defined the square root of the kernel function (<code>sqrt_kernel</code>), we just follow the regular procedure of sampling from the normal distribution. Since the covariance matrix in the Fourier space is diagonal, Gaussian variables in each bin are independent of each other. Thus, sampling ends up rescaling the <code>gp_latent</code> part of the prior vector responsible for the Gaussian process state.</p><p>After we produced a sample of Gaussian random values following the kernel model, we apply a Fourier transform to return back to the coordinate space.</p><pre><code class="language-julia hljs">function gp_sample(p)
    flat_gp = sqrt_kernel(p) .* p[PARIDX.gp_latent]
    (ht * flat_gp) .* _GP_HARMONIC_DIST
end;</code></pre><p>Together with the implementation of <code>gp_sample</code> we also need to define its version of the <code>Dual</code>s. This will allow our application of the Hartley transform to be differentiatiable.</p><pre><code class="language-julia hljs">function gp_sample(dp::Vector{ForwardDiff.Dual{T, V, N}}) where {T,V,N}
    flat_gp_duals = sqrt_kernel(dp) .* dp[PARIDX.gp_latent]
    val_res = ht*ForwardDiff.value.(flat_gp_duals) .* _GP_HARMONIC_DIST
    psize = size(ForwardDiff.partials(flat_gp_duals[1]), 1)
    ps = x -&gt; ForwardDiff.partials.(flat_gp_duals, x)
    val_ps = map((x -&gt; ht*ps(x) .* _GP_HARMONIC_DIST), 1:psize)
    ForwardDiff.Dual{T}.(val_res, val_ps...)
end;</code></pre><p>Gaussian process realization is meant to serve as a Poisson rate of the Poisson process. Since the Gaussian process is not restricted to positive values, we exponentiate its values to forcefully make the function positive.</p><pre><code class="language-julia hljs">function poisson_gp_link(fs)
    exp.(fs)
end;</code></pre><p>Now when we have a function representing the Poisson rate density, we have to integrate it over each data bin to define the Poisson rate in these bins. Function <code>agg_lambdas</code> does precisely that. When <code>GP_GRAIN_FACTOR = 1</code>, this function just multiplies the value of the Gaussian process in the bin by the <code>_GP_BINSIZE</code>. When we have more GP bins per data bin (<code>GP_GRAIN_FACTOR &gt; 1</code>), then we apply rectangular quadrature to integrate over the bin.</p><pre><code class="language-julia hljs">function _forward_agg(data, idxs, steps_forward)
    [sum(data[i:i+steps_forward-1]) for i in idxs]
end;

function agg_lambdas(lambdas)
    gps = _forward_agg(lambdas, _DATA_IDXS, GP_GRAIN_FACTOR) .* _GP_BINSIZE
    xs = _GP_XS[_DATA_IDXS .+ (GP_GRAIN_FACTOR ÷ 2)]
    xs, gps
end;</code></pre><p>Finally, we define the model by using the building blocks defined above:</p><ul><li><code>gp_sample</code> sample from the Gaussian process with defined <code>sqrt_kernel</code> covariance</li><li><code>poisson_gp_link</code> ensures Gaussian process is positive</li><li><code>agg_lambdas</code> integrates Gaussian process over each data bin to turn it into a Poisson rate for each bin</li><li><code>model</code> maps parameters into the product of the Poisson distribution&#39;s counting events in each bin.</li></ul><pre><code class="language-julia hljs">function model(params)
    fs = gp_sample(params)
    fine_lambdas = poisson_gp_link(fs)
    _, lambdas = agg_lambdas(fine_lambdas)
    product_distribution(fwddiff(Poisson).(lambdas))
end;</code></pre><h2 id="Visualization-utilities"><a class="docs-heading-anchor" href="#Visualization-utilities">Visualization utilities</a><a id="Visualization-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-utilities" title="Permalink"></a></h2><pre><code class="language-julia hljs">function agg_full_lambdas(lambdas)
    left_idxs = 1:GP_GRAIN_FACTOR:(_DATA_IDXS[1]-GP_GRAIN_FACTOR)
    left_gp = _forward_agg(lambdas, left_idxs, GP_GRAIN_FACTOR) .* _GP_BINSIZE
    left_xs = _GP_XS[left_idxs .+ (GP_GRAIN_FACTOR ÷ 2)]
    right_idxs = (_DATA_IDXS[end]+1):GP_GRAIN_FACTOR:(size(lambdas, 1) - GP_GRAIN_FACTOR)
    right_gp = _forward_agg(lambdas, right_idxs, GP_GRAIN_FACTOR) .* _GP_BINSIZE
    right_xs = _GP_XS[right_idxs .+ (GP_GRAIN_FACTOR ÷ 2)]
    middle_xs, middle_gp = agg_lambdas(lambdas)
    full_xs = [left_xs; middle_xs; right_xs]
    full_gp = [left_gp; middle_gp; right_gp]
    full_xs, full_gp
end;

function _mean(p; full=false)
    agg_func = if (!full) agg_lambdas else agg_full_lambdas end
    xs, gps = agg_func(poisson_gp_link(gp_sample(p)))
    xs, gps
end;

function plot_mean(p, label=&quot;mean&quot;; plot_args=(;), full=false)
    plot!(_mean(p; full=full)...; label=label, linewidth=3, plot_args...)
end;

function plot_prior_samples(num_samples; mean_plot_args=(;))
    for _ in 1:num_samples
        p = randn(last(PARIDX).stop)
        plot_mean(p, nothing; plot_args=mean_plot_args)
    end
end;

function plot_kernel_prior_samples(num_samples, width)
    for _ in 1:num_samples
        p = randn(last(PARIDX).stop)
        plot_kernel_model(p, width)
    end
    plot!()
end;

function plot_data(; scatter_args=(;), smooth_args=(;))
    bar!(_GP_XS[_DATA_IDXS .+ (GP_GRAIN_FACTOR ÷ 2)], data, color=:deepskyblue2, la=0, markersize=2., markerstrokewidth=0, alpha=0.4, label=&quot;data&quot;; scatter_args...)
    smooth_step = 4
    smooth_xs = _GP_XS[_DATA_IDXS .+ (GP_GRAIN_FACTOR ÷ 2)][(smooth_step+1):(end-smooth_step)]
    smooth_data = [sum(data[i-smooth_step:i+smooth_step])/(2*smooth_step+1) for i in (smooth_step+1):(size(data, 1)-smooth_step)]
    plot!(smooth_xs, smooth_data, color=:deeppink3, linewidth=3, linealpha=1, ls=:dash, label=&quot;smooth data&quot;; smooth_args...)
end;

function plot_mgvi_samples(samples)
    for sample in eachcol(samples)
        if any(isnan.(sample))
            print(&quot;nan found in samples&quot;, &quot;\n&quot;)
            continue
        end
        plot!(_mean(Vector(sample))..., linealpha=0.5, linewidth=2, label=nothing)
    end
    plot!()
end;

function plot_kernel_mgvi_samples(samples, width)
    for sample in eachcol(samples)
        if any(isnan.(sample))
            print(&quot;nan found in samples&quot;, &quot;\n&quot;)
            continue
        end
        plot_kernel_model(sample, width; plot_args=(linealpha=0.5, linewidth=2, label=nothing))
    end
    plot!()
end;

function produce_posterior_samples(p, num_residuals)
    batch_size = 10

    if num_residuals &lt;= 2*batch_size
        batch_size = num_residuals ÷ 2
    end

    est_res_sampler = MGVI.ResidualSampler(
        model, p, KrylovJL_CG((atol=1E-2,)), context
    )
    batches = []
    for _ in 1:(num_residuals ÷ batch_size ÷ 2)
        batch_residual_samples = MGVI.sample_residuals(est_res_sampler, batch_size)
        push!(batches, p .+ batch_residual_samples)
        push!(batches, p .- batch_residual_samples)
    end
    reduce(hcat, batches)
end

function _extract_quantile(sorted_gp_realizations, p)
    map(s -&gt; quantile(s, p; sorted=true), eachrow(sorted_gp_realizations))
end;

function plot_posterior_bands(p, num_samples; full=false)
    bands = [(0.997, :red), (0.955, :goldenrod1), (0.683, :green)]
    samples = produce_posterior_samples(p, num_samples)
    xs, first_gp = _mean(samples[1:end, 1]; full=full)
    gp_realizations = reduce(hcat, [_mean(Vector(sample); full=full)[2] for sample in eachcol(samples[1:end, 2:end])]; init=first_gp)
    for (i, one_x_sample) in enumerate(eachrow(gp_realizations))
        gp_realizations[i, 1:end] .= sort(Vector(one_x_sample))
    end
    for (band, color) in bands
        quant_l = _extract_quantile(gp_realizations, (1-band)/2)
        quant_u = _extract_quantile(gp_realizations, (1+band)/2)
        plot!(xs, quant_l; fillrange=quant_u, fillcolor=color, linealpha=0, label=band)
    end
    sample_median = _extract_quantile(gp_realizations, 0.5)
    plot!(xs, sample_median; linewidth=2, linecolor=:grey25, label=&quot;median&quot;)
end;</code></pre><h2 id="Visualization-and-fitting"><a class="docs-heading-anchor" href="#Visualization-and-fitting">Visualization and fitting</a><a id="Visualization-and-fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-and-fitting" title="Permalink"></a></h2><p>We start by plotting the Gaussian process&#39;s dynamic range by sampling many possible realizations of it unconditionally on the data. We expect the set of lines to populate the regions where there are data.</p><pre><code class="language-julia hljs">plot()
plot_data(;scatter_args=(;alpha=0.7))
plot_prior_samples(200, mean_plot_args=(;alpha=0.5))
plot!(ylim=[0, 8])
savefig(&quot;advtut-plot3.png&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;/home/runner/work/MGVI.jl/MGVI.jl/docs/build/advtut-plot3.png&quot;</code></pre><p><a href="../advtut-plot3.png"><img src="../advtut-plot3.png" alt="Plot"/></a></p><p>We also plot prior samples for the kernel in the coordinate space. The plot below shows that the kernel is flexible in the amplitude while the correlation length is quite strongly predefined:</p><pre><code class="language-julia hljs">plot()
plot_kernel_prior_samples(200, 20)
savefig(&quot;advtut-plot4.pdf&quot;)</code></pre><p><a href="../advtut-plot4.pdf"><img src="../advtut-plot4.svg" alt="Plot"/></a></p><p>Now that we see that the Gaussian process is potentially able to fit the data, we plot the initial guess (<code>starting_point</code>) to see where we should start from. This plot shows:</p><ul><li>data points</li><li>smoothed data with a moving average of 9 years</li><li>Poisson rate for each bin</li><li>MGVI samples around the mean. At the later stages they can be used to estimate MGVI&#39;s uncertainty</li></ul><pre><code class="language-julia hljs">plot()
plot_data()
plot_mean(starting_point, &quot;starting point&quot;; plot_args=(;color=:darkorange2))
plot_mgvi_samples(produce_posterior_samples(starting_point, 6))
savefig(&quot;advtut-plot5.pdf&quot;)</code></pre><p><a href="../advtut-plot5.pdf"><img src="../advtut-plot5.svg" alt="Plot"/></a></p><p>We also want to introduce the <code>full</code> plot that shows not only the data region, but includes the region with the padding we added with <code>GP_PADDING</code>. We will use this plot to make sure that periodic boundary conditions don&#39;t interfere with the data.</p><pre><code class="language-julia hljs">plot()
plot_data()
plot_mean(starting_point, &quot;full gp&quot;; full=true, plot_args=(;color=:pink))
plot_mean(starting_point, &quot;starting point&quot;; plot_args=(;color=:darkorange2))
savefig(&quot;advtut-plot6.pdf&quot;)</code></pre><p><a href="../advtut-plot6.pdf"><img src="../advtut-plot6.svg" alt="Plot"/></a></p><p>Below we also plot the kernel and MGVI samples that represent the possible variation of the kernel shape around the mean:</p><pre><code class="language-julia hljs">plot()
plot_kernel_model(starting_point, 20; plot_args=(;label=&quot;kernel model&quot;))
plot_kernel_mgvi_samples(produce_posterior_samples(starting_point, 6), 20)
savefig(&quot;advtut-plot7.pdf&quot;)</code></pre><p><a href="../advtut-plot7.pdf"><img src="../advtut-plot7.svg" alt="Plot"/></a></p><p>Let&#39;s make a first iteration of the MGVI. For purposes of displaying the convergence curve, we limit the optimization to 1 step so that MGVI will coverge more slowly.</p><pre><code class="language-julia hljs">config = MGVIConfig(
    linsolver = KrylovJL_CG((;itmax=10)),
    optimizer = MGVI.NewtonCG(steps = 1)
)
result, center_point = mgvi_step(model, data, 3, starting_point, config, context);</code></pre><p>We again plot data and the Poisson rate. We again show the Gaussian process with padding. After one iteration the Poisson rate doesn&#39;t seem to get much closer to the data.</p><pre><code class="language-julia hljs">plot()
plot_data()
plot_mean(center_point, &quot;first iteration&quot;; plot_args=(;color=:darkorange2))
plot_mgvi_samples(result.samples)
savefig(&quot;advtut-plot8.pdf&quot;)</code></pre><p><a href="../advtut-plot8.pdf"><img src="../advtut-plot8.svg" alt="Plot"/></a></p><pre><code class="language-julia hljs">plot()
plot_data()
plot_mean(center_point, &quot;full gp&quot;; full=true, plot_args=(;color=:pink))
plot_mean(center_point, &quot;first iteration&quot;; plot_args=(;color=:darkorange2))
savefig(&quot;advtut-plot9.pdf&quot;)</code></pre><p><a href="../advtut-plot9.pdf"><img src="../advtut-plot9.svg" alt="Plot"/></a></p><p>Kernel and its MGVI samples changed significantly in comparison to the <code>starting_point</code> even after the first iteration:</p><pre><code class="language-julia hljs">plot()
plot_kernel_model(center_point, 20; plot_args=(;label=&quot;kernel model&quot;))
plot_kernel_mgvi_samples(result.samples, 20)
savefig(&quot;advtut-plot10.pdf&quot;)</code></pre><p><a href="../advtut-plot10.pdf"><img src="../advtut-plot10.svg" alt="Plot"/></a></p><p>In order to visualize convergence we prepare a few functions to compute, store and plot the average posterior likelihood of.</p><pre><code class="language-julia hljs">function compute_avg_likelihood(model, samples, data)
    tot = 0
    for sample in eachcol(samples)
        tot += -MGVI.posterior_loglike(model, sample, data)
    end
    tot/size(samples, 2)
end;

function show_avg_likelihood(series)
    scatter!(1:size(series, 1), series, label=&quot;-loglike&quot;)
end;</code></pre><p>Now we do 30 more iterations of the MGVI and store the average likelihood after each step. We feed the fitted result of the previous step as an input to the next iteration.</p><pre><code class="language-julia hljs">config = MGVIConfig(
    linsolver = KrylovJL_CG((;atol=1E-2,verbose=false)),
    optimizer = MGVI.NewtonCG()
)

avg_likelihood_series = [];
push!(avg_likelihood_series, compute_avg_likelihood(model, result.samples, data));
for i in 1:30
    global result, center_point = mgvi_step(model, data, 3, center_point, config, context);
    push!(avg_likelihood_series, compute_avg_likelihood(model, result.samples, data))
end;</code></pre><p>First, let&#39;s have a look at the convergence plots. We see that MGVI converged after 10 iterations while being limited to very poor <code>Optim</code> performance.</p><pre><code class="language-julia hljs">plot(yscale=:log)
show_avg_likelihood(avg_likelihood_series)
savefig(&quot;advtut-plot11.pdf&quot;)</code></pre><p><a href="../advtut-plot11.pdf"><img src="../advtut-plot11.svg" alt="Plot"/></a></p><p>Below we plot the result of the fit. Together with the data and Poisson rate, we also plot MGVI residuals. These are samples from the Gaussian posterior, sampled with respect to the posterior&#39;s covariance structure. Thus MGVI residual samples are deviations from the MGVI fit and represent how confident we are about the prediction.</p><pre><code class="language-julia hljs">plot(ylim=[0,8])
plot_data()
plot_mgvi_samples(result.samples)
plot_mean(center_point, &quot;many iterations&quot;; plot_args=(;color=:darkorange2))
savefig(&quot;advtut-plot12.pdf&quot;)</code></pre><p><a href="../advtut-plot12.pdf"><img src="../advtut-plot12.svg" alt="Plot"/></a></p><p>To present credibility intervals we also plot credibility bands. We sample 400 residual samples from MGVI and then plot quantiles for each data bin. This should give us a feeling of how compatible the MGVI fit is with the data.</p><pre><code class="language-julia hljs">plot(ylim=[0,8])
plot_posterior_bands(center_point, 400)
plot_data()
plot_mean(center_point, &quot;many iterations&quot;; plot_args=(;color=:darkorange2))
savefig(&quot;advtut-plot13.pdf&quot;)</code></pre><p><a href="../advtut-plot13.pdf"><img src="../advtut-plot13.svg" alt="Plot"/></a> We also make sure boundary conditions do not interfere with the data. Here is the Gaussian process plot with the paddings included:</p><pre><code class="language-julia hljs">plot()
plot_data()
plot_mean(center_point; full=true, plot_args=(;color=:pink))
plot_mean(center_point, &quot;many iterations&quot;; plot_args=(;color=:darkorange2))
savefig(&quot;advtut-plot14.pdf&quot;)</code></pre><p><a href="../advtut-plot14.pdf"><img src="../advtut-plot14.svg" alt="Plot"/></a></p><p>Let&#39;s have a look at the kernel again. We expect the variation of samples to become narrower:</p><pre><code class="language-julia hljs">plot()
plot_kernel_model(center_point, 20; plot_args=(;label=&quot;kernel model&quot;))
plot_kernel_mgvi_samples(result.samples, 20)
savefig(&quot;advtut-plot15.pdf&quot;)</code></pre><p><a href="../advtut-plot15.pdf"><img src="../advtut-plot15.svg" alt="Plot"/></a></p><h2 id="Maximum-a-posteriori-estimation"><a class="docs-heading-anchor" href="#Maximum-a-posteriori-estimation">Maximum a posteriori estimation</a><a id="Maximum-a-posteriori-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Maximum-a-posteriori-estimation" title="Permalink"></a></h2><p>We build a MAP as a cross check of MGVI results. We simply optimize the posterior likelihood by using <code>Optim</code> without any particular tuning settings:</p><pre><code class="language-julia hljs">max_posterior = Optim.optimize(x -&gt; -MGVI.posterior_loglike(model, x, data), starting_point, LBFGS(), Optim.Options(show_trace=false, g_tol=1E-6, iterations=30));</code></pre><p>We observe that the bump in the middle (around 1910) is caught by the MAP while it is less pronounced in the MGVI fit. MAP also has finer structure around 1875 and 1835.</p><pre><code class="language-julia hljs">plot()
plot_data()
plot_mean(center_point, &quot;mgvi mean&quot;; plot_args=(;color=:darkorange2))
plot_mean(Optim.minimizer(max_posterior), &quot;map&quot;)
savefig(&quot;advtut-plot16.pdf&quot;)</code></pre><p><a href="../advtut-plot16.pdf"><img src="../advtut-plot16.svg" alt="Plot"/></a></p><p>We also can see the difference at the left edge of the data region. While MGVI smoothed the data, the MAP predicted a consequent peak:</p><pre><code class="language-julia hljs">plot()
plot_data()
plot_mean(Optim.minimizer(max_posterior), &quot;full gp&quot;; full=true, plot_args=(;color=:darkorange2))
plot_mean(center_point, &quot;mgvi full gp&quot;; full=true)
savefig(&quot;advtut-plot17.pdf&quot;)</code></pre><p><a href="../advtut-plot17.pdf"><img src="../advtut-plot17.svg" alt="Plot"/></a></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 23 October 2024 08:58">Wednesday 23 October 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
